// Code generated by go-swagger; DO NOT EDIT.

// /**
//  * OpenPSD PSD2 Server
//  * 2018 - OpenPSD - openpsd.org
//  * Released under the GNU General Public License
//  */

package account

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"net/http"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/runtime/middleware"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"

	strfmt "github.com/go-openapi/strfmt"
)

// NewAccountsTransactionsByAccountIDGetParams creates a new AccountsTransactionsByAccountIDGetParams object
// no default values defined in spec.
func NewAccountsTransactionsByAccountIDGetParams() AccountsTransactionsByAccountIDGetParams {

	return AccountsTransactionsByAccountIDGetParams{}
}

// AccountsTransactionsByAccountIDGetParams contains all the bound params for the accounts transactions by account Id get operation
// typically these are obtained from a http.Request
//
// swagger:parameters AccountsTransactionsByAccountIdGet
type AccountsTransactionsByAccountIDGetParams struct {

	// HTTP Request Object
	HTTPRequest *http.Request `json:"-"`

	/*The TPP can indicate the formats of account reports supported together with a priorisation following the HTTP header definition.
	  In: header
	*/
	Accept *string
	/*Is contained only, if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in the related consent authorisation.
	  In: header
	*/
	Authorization *string
	/*Shall be contained since "Establish Consent Transaction" was performed via this API before.
	  Required: true
	  In: header
	*/
	ConsentID string
	/*Is contained if and only if the "Signature" element is contained in the header of the request.
	  In: header
	*/
	Digest *string
	/*A signature of the request by the TPP on application level. This might be mandated by ASPSP.
	  In: header
	*/
	Signature *string
	/*The certificate used for signing the request, in base64 encoding. It shall be contained if a signature is used, see above.
	  In: header
	*/
	TPPSignatureCertificate *string
	/*ID of the request, unique to the call, as determined by the initiating party.
	  Required: true
	  In: header
	*/
	XRequestID strfmt.UUID
	/*This identification is denoting the addressed account. The account-id is retrieved by using a "Read Account List" call. The account-id is the "resourceId" attribute of the account structure. Its value is constant at least throughout the lifecycle of a given consent.
	  Required: true
	  In: path
	*/
	AccountID string
	/*Permitted codes are "booked", "pending" and "both "booked" shall be supported by the ASPSP. To support the "pending" and "both" feature is optional for the ASPSP, Error code if not supported in the online banking frontend
	  Required: true
	  In: query
	*/
	BookingStatus string
	/*Starting date (inclusive the date dateFrom) of the transaction list, mandated if no delta access is required
	  In: query
	*/
	DateFrom *strfmt.Date
	/*End date (inclusive the data dateTo) of the transaction list, default is now if not given.
	  In: query
	*/
	DateTo *strfmt.Date
	/*This data attribute is indicating that the AISP is in favour to get all transactions after the last report access for this PSU on the addressed account. This is another implementation of a delta access-report. This delta indicator might be rejected by the ASPSP if this function is not supported.
	  In: query
	*/
	DeltaList *bool
	/*This data attribute is indicating that the AISP is in favour to get all transactions after the transaction with identification entryReferenceFrom alternatively to the above defined period. This is a implementation of a delta access. If this data element is contained, the entries "dateFrom" and "dateTo" might be ignored by the ASPSP if a delta report is supported.
	  In: query
	*/
	EntryReferenceFrom *string
}

// BindRequest both binds and validates a request, it assumes that complex things implement a Validatable(strfmt.Registry) error interface
// for simple values it will use straight method calls.
//
// To ensure default values, the struct must have been initialized with NewAccountsTransactionsByAccountIDGetParams() beforehand.
func (o *AccountsTransactionsByAccountIDGetParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {
	var res []error

	o.HTTPRequest = r

	qs := runtime.Values(r.URL.Query())

	if err := o.bindAccept(r.Header[http.CanonicalHeaderKey("Accept")], true, route.Formats); err != nil {
		res = append(res, err)
	}

	if err := o.bindAuthorization(r.Header[http.CanonicalHeaderKey("Authorization")], true, route.Formats); err != nil {
		res = append(res, err)
	}

	if err := o.bindConsentID(r.Header[http.CanonicalHeaderKey("Consent-ID")], true, route.Formats); err != nil {
		res = append(res, err)
	}

	if err := o.bindDigest(r.Header[http.CanonicalHeaderKey("Digest")], true, route.Formats); err != nil {
		res = append(res, err)
	}

	if err := o.bindSignature(r.Header[http.CanonicalHeaderKey("Signature")], true, route.Formats); err != nil {
		res = append(res, err)
	}

	if err := o.bindTPPSignatureCertificate(r.Header[http.CanonicalHeaderKey("TPP-Signature-Certificate")], true, route.Formats); err != nil {
		res = append(res, err)
	}

	if err := o.bindXRequestID(r.Header[http.CanonicalHeaderKey("X-Request-ID")], true, route.Formats); err != nil {
		res = append(res, err)
	}

	rAccountID, rhkAccountID, _ := route.Params.GetOK("account-id")
	if err := o.bindAccountID(rAccountID, rhkAccountID, route.Formats); err != nil {
		res = append(res, err)
	}

	qBookingStatus, qhkBookingStatus, _ := qs.GetOK("bookingStatus")
	if err := o.bindBookingStatus(qBookingStatus, qhkBookingStatus, route.Formats); err != nil {
		res = append(res, err)
	}

	qDateFrom, qhkDateFrom, _ := qs.GetOK("dateFrom")
	if err := o.bindDateFrom(qDateFrom, qhkDateFrom, route.Formats); err != nil {
		res = append(res, err)
	}

	qDateTo, qhkDateTo, _ := qs.GetOK("dateTo")
	if err := o.bindDateTo(qDateTo, qhkDateTo, route.Formats); err != nil {
		res = append(res, err)
	}

	qDeltaList, qhkDeltaList, _ := qs.GetOK("deltaList")
	if err := o.bindDeltaList(qDeltaList, qhkDeltaList, route.Formats); err != nil {
		res = append(res, err)
	}

	qEntryReferenceFrom, qhkEntryReferenceFrom, _ := qs.GetOK("entryReferenceFrom")
	if err := o.bindEntryReferenceFrom(qEntryReferenceFrom, qhkEntryReferenceFrom, route.Formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AccountsTransactionsByAccountIDGetParams) bindAccept(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	o.Accept = &raw

	if err := o.validateAccept(formats); err != nil {
		return err
	}

	return nil
}

func (o *AccountsTransactionsByAccountIDGetParams) validateAccept(formats strfmt.Registry) error {

	if err := validate.Enum("Accept", "header", *o.Accept, []interface{}{"xml", "JSON", "text"}); err != nil {
		return err
	}

	return nil
}

func (o *AccountsTransactionsByAccountIDGetParams) bindAuthorization(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	o.Authorization = &raw

	return nil
}

func (o *AccountsTransactionsByAccountIDGetParams) bindConsentID(rawData []string, hasKey bool, formats strfmt.Registry) error {
	if !hasKey {
		return errors.Required("Consent-ID", "header")
	}
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true

	if err := validate.RequiredString("Consent-ID", "header", raw); err != nil {
		return err
	}

	o.ConsentID = raw

	return nil
}

func (o *AccountsTransactionsByAccountIDGetParams) bindDigest(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	o.Digest = &raw

	return nil
}

func (o *AccountsTransactionsByAccountIDGetParams) bindSignature(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	o.Signature = &raw

	return nil
}

func (o *AccountsTransactionsByAccountIDGetParams) bindTPPSignatureCertificate(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	o.TPPSignatureCertificate = &raw

	return nil
}

func (o *AccountsTransactionsByAccountIDGetParams) bindXRequestID(rawData []string, hasKey bool, formats strfmt.Registry) error {
	if !hasKey {
		return errors.Required("X-Request-ID", "header")
	}
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true

	if err := validate.RequiredString("X-Request-ID", "header", raw); err != nil {
		return err
	}

	// Format: uuid
	value, err := formats.Parse("uuid", raw)
	if err != nil {
		return errors.InvalidType("X-Request-ID", "header", "strfmt.UUID", raw)
	}
	o.XRequestID = *(value.(*strfmt.UUID))

	if err := o.validateXRequestID(formats); err != nil {
		return err
	}

	return nil
}

func (o *AccountsTransactionsByAccountIDGetParams) validateXRequestID(formats strfmt.Registry) error {

	if err := validate.FormatOf("X-Request-ID", "header", "uuid", o.XRequestID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (o *AccountsTransactionsByAccountIDGetParams) bindAccountID(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true
	// Parameter is provided by construction from the route

	o.AccountID = raw

	return nil
}

func (o *AccountsTransactionsByAccountIDGetParams) bindBookingStatus(rawData []string, hasKey bool, formats strfmt.Registry) error {
	if !hasKey {
		return errors.Required("bookingStatus", "query")
	}
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true
	// AllowEmptyValue: false
	if err := validate.RequiredString("bookingStatus", "query", raw); err != nil {
		return err
	}

	o.BookingStatus = raw

	return nil
}

func (o *AccountsTransactionsByAccountIDGetParams) bindDateFrom(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	// Format: date
	value, err := formats.Parse("date", raw)
	if err != nil {
		return errors.InvalidType("dateFrom", "query", "strfmt.Date", raw)
	}
	o.DateFrom = (value.(*strfmt.Date))

	if err := o.validateDateFrom(formats); err != nil {
		return err
	}

	return nil
}

func (o *AccountsTransactionsByAccountIDGetParams) validateDateFrom(formats strfmt.Registry) error {

	if err := validate.FormatOf("dateFrom", "query", "date", o.DateFrom.String(), formats); err != nil {
		return err
	}

	return nil
}

func (o *AccountsTransactionsByAccountIDGetParams) bindDateTo(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	// Format: date
	value, err := formats.Parse("date", raw)
	if err != nil {
		return errors.InvalidType("dateTo", "query", "strfmt.Date", raw)
	}
	o.DateTo = (value.(*strfmt.Date))

	if err := o.validateDateTo(formats); err != nil {
		return err
	}

	return nil
}

func (o *AccountsTransactionsByAccountIDGetParams) validateDateTo(formats strfmt.Registry) error {

	if err := validate.FormatOf("dateTo", "query", "date", o.DateTo.String(), formats); err != nil {
		return err
	}

	return nil
}

func (o *AccountsTransactionsByAccountIDGetParams) bindDeltaList(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("deltaList", "query", "bool", raw)
	}
	o.DeltaList = &value

	return nil
}

func (o *AccountsTransactionsByAccountIDGetParams) bindEntryReferenceFrom(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	o.EntryReferenceFrom = &raw

	return nil
}
